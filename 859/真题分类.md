### dp类
- 一个数组的最大连续子和
- 设计算法求一个数组的最大区间和的值（暴力解不得分，O(n2)可得部分分数，O(n)的
算法才可能得满分。
- 给定一个长度为n，飞整型数组a，求最长上升子序列的长度。
- 输入一个由数字组成的字符串，将数字与字母对应，求一串数字能够对应的所有非空字
母序列，完成转换。
  
1）给出算法思路，最好配图 

2）写出伪代码  

3）分析时间复杂度

### 排序类
- CBA算法：通过直接比较元素大小来决定排序顺序的算法，有冒泡、选择、插入、希尔、归并、快排、堆排等，时间复杂度至少为nlogn
- 实现⽂件类复制连接⽐较排序
- 从算法原理，性能角度，例举插入排序和选择排序算法之间的类似或者区别
- 算法填空，归并排序(二路归并)

### 类模板
- 编写模版函数求数组a 的中位数，a可能是整型数组也可能是浮点型数组。
- 实现类模版：考察类模版格式，实现分配数组、删除数组、排序的基本功能
- 固定容量双向序列模版类、写成员函数模版、数据结构

### 重载
- 编写一维数组类，重载operator 操作符实现以下四个操作：1）……2）整体右移一位3）两个数组相加？ 4）……
- 矩阵类对象的实现，使用operator()重载运算符实现： 1）矩阵相加 2）矩阵相乘 DSA
- 重载运算符友元输⼊输出
- 2011年还有一道
- 代码填空(35分)程序实现中缀转后缀重载<运算符用来比较运算符优先级输入:1-2*(3+4)输出:1234+*

### 文件
- 实现⽂件类复制连接⽐较排序
- 输⼊输出控制和实现函数
- 文件流的问题1)打开文件2)判断打开成功了吗3)在文件中存入数字 4)打开文件5)读取文件中的数字

### 二叉树
  - 已知二叉树的中序遍历、先序遍历、后序遍历。
  1）证明任何两个遍历都可以推断出二叉树的结构。
  *我认为应该是具体给了字符。*
*前序：根左右ABC。后序：左右根CBA。两者都没有提供左右子树划分的关键信息——中序的“根在中间”特性才是划分左右的关键。
对应的树又*
  1)    A      2)    A      
     /           /        
    B           B        
   /             \       
  C               C     

 2）一个和二叉树相关的算法的思路 3）该算法的时间复杂度。
 
  - 1)已知前序序列和中序序列，画出二叉树，写出后序序列
  - 二叉树的中序遍历（名词解释）
    *二叉树的中序遍历是二叉树递归遍历的一种方式，对任意一颗二叉树，其访问顺序遵循“左子树-根结点-右子树”的规则。中序遍历在二叉搜索树中有重要应用：对一颗二叉搜索树进行中序遍历，得到的结点值序列是单调非降的。这一性质常被用于二叉搜索树的验证、排序输出等场景。*
（后续遍历的应用：逆波兰表达式，考试不太考，但是可以看看算法）

  - 2)二叉树用二叉链表实现，查找前序遍历的第一个节点，设计算法，不用栈和递归实现 写出伪代码
  - 1)伪代码 要求:可以使用栈或者队列,但不能使用其他数据结构。节点总是为n，二叉树高度为h，时间 复杂度为0(n)，空间复杂度为0(h)2)解释算法3)解释正确性4)解释时间复杂度、空间复杂度符合要求
  - 举例说明多叉堆比正常二叉堆效率高，分析时间复杂度并说明应该如何分叉
  - 说明任一棵有根有序多叉树，如何能够唯一对应于一棵二叉树；
  - 数据结构的题目，实现⼆叉排列树类
  - 特殊多叉树的算法、修改
  - AVL、B树、
  - 给定二叉树的前序遍历序列和中序遍历序列，可以唯一地确定一颗二叉树
  - 高度为h的完全二叉树的个数是
  
### deque
- 某个队列允许一端入队两端出队，入队过程中可以出队，则当入队顺序为ABCDE时不可能得到EBCAD的出 队顺序
- 双端队列中有头尾指针，经过下面的操作push pop push push pop push push pop pop push pop push，最少需要申请的数组长度为
- 求字符串的无重复子串长度

### 栈
- 将中缀表达式（0！+1）*2^（3！+4）-5/6-（7-8+9）转换为逆波兰表达式，写进44455的格子
- 程序实现中缀转后缀重载<运算符用来比较运算符优先级输入:1-2*(3+4)输出:1234+* 还有两年考了
  
 如何将中缀表达式转为后缀表达式
>
> 遍历到数字，直接放在表达式中不进栈
>
> 遍历到+-(随便进栈
> 
> 遍历到），弹出里面的符号，直到找到（匹配他，弹出直接消除。
> 
> 栈顶元素的优先级>=当前扫描到的元素，弹出栈顶元素，放在后缀表达式中。继续比较，弹出，直到<，入栈。扫描完就依次弹出
>
> ）的优先级是最高的，任何高优先级符号都只能乖乖等着。不过只是！和（相比，！碰到+还是！弹出了
>
> 但是碰到（，里面的不弹出

 如何通过后缀表达式，计算最终的结果
> 
> 遍历到数字，进栈
> 
> 遍历到运算符，弹出两个数字，栈顶放右边，第二个放左边，得出数字进栈
>
> ！只和自己算是因为一元运算符

出栈秒杀法：312禁止
> 入栈顺序是ABC，则CAB是不对的
- 括号匹配有个简答题（伪代码、简述原理）
  
#### 向量
- 如何基于向量结构，派生出栈结构
  将向量首端作为栈底，末端作为栈顶，入栈和出栈只能操作向量末端：当入栈（push）时，只在向量末端插入。当出栈（pop）时，只弹出向量末端元素。取顶（top）返回向量末端元素，其他操作默认继承vector类。
  
  这样设计可以保证所有栈操作的时间复杂度都是<kbd>O(1)</kbd>，因为向量的push_back、pop_back、back操作都是常数时间复杂度的。
  （列表一样的）
  
  *多写一点这种基础数据结构派生的题*

- 向量扩容增量操作分摊时间0(1)
- 空间申请扩展的时间复杂度。申请一次空间（new）需要消耗O(log n)，删除一次空间同样
  
需要O(log n)的时间。对于达到M 的空间，n 为每次申请空间，求时间复杂度。 

1. n={1,2,3,4,5… }
   
3. n=(1,2,4,8,16,32…)
   
5. 尝试设计递增算法，使得时间复杂度满足O(log M)
   
- 25年动态数组
  
### 复杂度
- 递归算法时间，空间复杂度分别主要决定于哪些因素；

2)解释算法

3)解释正确性

4)解释时间复杂度、空间复杂度符合要求
- 二叉搜索树(BST)在查找元素最坏情况是0(n)( )

- 大O 记号

- 2）一个和二叉树相关的算法的思路 3）该算法的时间复杂度。

- - 就地算法
就地算法（In-place Algorithm）是指在算法执行过程中，除了输入数据本身占用的空间外，只使用常数额外空间（O(1)额外空间） 的算法。

- 大O符号是算法复杂度分析的核心工具，用于量化算法时间/空间需求随输入规模增长的变化趋势。它关注最坏情况下的渐近上界，忽略常数因子，突出主导项。
- 在数据集理想随机时，为什么平凡算法和优化算法的效果实质上可能差别不大。举两个例子，并解释。

### 图
- 所有的无向图的度都是边数的两倍。（）

因为每条边一定贡献给两个端点各1度。即便这条边是自环（自己连自己），通常约定自环贡献2度。所以总和总是边数的两倍。
  
- 对比说明邻接矩阵和邻接表的优势和劣势
  邻接矩阵使用矩阵[n][n]描述图的各个顶点的临界关系。对无权图而言，当存在某个顶点指向另一个顶点的边时，就以出点为纵列，入点为横列的单元填入1。在带权网络中，可将矩阵单元用于记录对应边的权重，不存在的边通常取值为0或∞。

  邻接表是将各个
  
- Prime算法、Kruscal临接表；
- 深度优先搜索能用于判断有向图的回路
- Dijkstra算法可以解决任何图的单源最短路径问题

### 哈希
- 发扑克牌
- 散列函数
  
### 倒转
- 实现句⼦的逆序输出，如，输⼊：i am a student , 输出：student a am I；
- 逆序输出只识别宇母和空格，逆序输出各个单词输入:love TsingHua University输出:University Tsinghua love l输入:| lo*e Ts/ngHua Un¥vers&ty输出:ty vers Un ngHua Ts e lo l
- 输入一个由数字组成的字符串，将数字与字母对应，求一串数字能够对应的所有非空字母序列，完成转换
- 逆序对

### 二分查找
- 插值查找（就是按比例查找）
- 二路归并
- 二分查找（这是名词解释，25也考了）

### 文件
- 实现⽂件类复制连接⽐较排序；

### 数学
- 编程实现大数加法。十进制正整数X1 X2 X1 X2 位数不超过1000，最高位不是0，1＜X1＜101000, 1＜X2＜101000，输出两个数的和。
- 实现100000 以内的相亲数对输出 
相亲数：除自身以外的约数和，比如220：1+2+4+5+10+11+20+22+44+55+110=284，

284：1+2+4+71+142=220，所以220 和284 构成相亲数对。 

输出格式：从小到大每行一对相亲数对，中间一个空格隔开。

- 高精度阶乘的实现，补全代码。


