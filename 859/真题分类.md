### dp类
- 一个数组的最大连续子和
- 设计算法求一个数组的最大区间和的值（暴力解不得分，O(n2)可得部分分数，O(n)的
算法才可能得满分。
- 给定一个长度为n，飞整型数组a，求最长上升子序列的长度。
  
### 回溯
- 输入一个由数字组成的字符串，将数字与字母对应，求一串数字能够对应的所有非空字母序列，完成转换。
- 上题：给定一个数字字符串（如 "23"），数字 2-9 对应手机键盘上的字母（2->"abc", 3->"def", ...）。要求输出所有可能的字母组合（如 "ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"）。
1）给出算法思路，最好配图 
2）写出伪代码  
3）分析时间复杂度
太难了算了

- 八皇后（这个可以练练）算了我压不考回溯

### 排序类
- CBA算法：通过直接比较元素大小来决定排序顺序的算法，有冒泡、选择、插入、希尔、归并、快排、堆排等，时间复杂度至少为nlogn
- 从算法原理，性能角度，例举插入排序和选择排序算法之间的类似或者区别
- 算法填空，归并排序(二路归并)
- 快速排序算法平均的情况下，该算法的时间复杂度最坏的时间复杂度仍然是nlogn
- 归并排序:快速排序递归算法都不会递归到最底层，当子序列长度小于某个阈值m时提前停止递归用朴素的算法直接对子序列排序，这样处理处于什么考虑，阈值m的主要因素有哪些。
  这描述的是混合排序策略（Hybrid Sorting），结合了快速排序/归并排序的分治递归和简单排序（如插入排序）的小数组高效性。“朴素的算法”通常指插入排序。
  
排序算法	处理小数组的问题

快速排序	递归调用、划分操作有固定开销，当数组很小时，这些开销占比很大。

归并排序	需要额外的合并操作和辅助空间，小数组上这些操作不划算。

插入排序	对小规模、基本有序的数组，实际运行速度极快（常数因子小，且是原地排序）。

- 逆序对
  如果 i < j 且 a[i] > a[j]，则 (i, j) 是一个逆序对

### 类模板
- 编写模版函数求数组a 的中位数，a可能是整型数组也可能是浮点型数组。
- 实现类模版：考察类模版格式，实现分配数组、删除数组、排序的基本功能
- 固定容量双向序列模版类、写成员函数模版、数据结构

### 重载
- 编写一维数组类，重载operator 操作符实现以下四个操作：2）整体右移一位3）两个数组相加？
- 矩阵类对象的实现，使用operator()重载运算符实现： 1）矩阵相加 2）矩阵相乘 DSA
- 重载运算符友元输⼊输出
- 2011年还有一道
- 代码填空(35分)程序实现中缀转后缀重载<运算符用来比较运算符优先级输入:1-2*(3+4)输出:1234+*
- 实现⽂件类复制连接⽐较排序(ai都没法还原算了，可能是重载)

### 文件
- 输⼊输出控制和实现函数
- 文件流的问题1)打开文件2)判断打开成功了吗3)在文件中存入数字 4)打开文件5)读取文件中的数字

### 二叉树
  - 由abc三个节点存储的二叉树一共有6种。 5种，卡特兰数
    
  - 已知二叉树的中序遍历、先序遍历、后序遍历。
  1）证明任何两个遍历都可以推断出二叉树的结构。
  *我认为应该是具体给了字符。*
*前序：根左右ABC。后序：左右根CBA。两者都没有提供左右子树划分的关键信息——中序的“根在中间”特性才是划分左右的关键。
对应的树又*
  1)    A      2)    A      
     /           /        
    B           B        
   /             \       
  C               C     

 2）一个和二叉树相关的算法的思路 3）该算法的时间复杂度。
 
  - 1)已知前序序列和中序序列，画出二叉树，写出后序序列
  - 二叉树的中序遍历（名词解释）
    *二叉树的中序遍历是二叉树递归遍历的一种方式，对任意一颗二叉树，其访问顺序遵循“左子树-根结点-右子树”的规则。中序遍历在二叉搜索树中有重要应用：对一颗二叉搜索树进行中序遍历，得到的结点值序列是单调非降的。这一性质常被用于二叉搜索树的验证、排序输出等场景。*
（后续遍历的应用：逆波兰表达式，考试不太考，但是可以看看算法）

  - 二叉树用二叉链表实现，查找前序遍历的第K个节点，设计算法，不用栈和递归实现 写出伪代码
    注意链式储存和线性储存
    
  - 1)伪代码 要求:可以使用栈或者队列,但不能使用其他数据结构。节点总是为n，二叉树高度为h，时间 复杂度为0(n)，空间复杂度为0(h)2)解释算法3)解释正确性4)解释时间复杂度、空间复杂度符合要求
  - 说明任一棵有根有序多叉树，如何能够唯一对应于一棵二叉树；
    左指针 指向结点的第一个孩子（相当于多叉树中该结点的第一个子结点）。

右指针 指向结点的下一个兄弟（相当于多叉树中该结点的右侧兄弟结点）。

通过这种规则，多叉树的“父子”和“兄弟”关系被完全映射到二叉树的“左孩子”和“右兄弟”关系中。
长子-兄弟
1. 将同一结点的孩子结点之间用线两两连起来
   
3. 去掉除父结点与长子结点连线外父节点与其他孩子结点的连线 (步骤1,2即是用长子+兄弟表示法)
   
5. 将整棵树顺时针旋转45度即可得到二叉树

        
   
  - 数据结构的题目，实现⼆叉排列树类
  - 特殊多叉树的算法、修改

  - 中序遍历
  - 1)伪代码 要求:可以使用栈或者队列，但不能使用其他数据结构。节点总是为n，二叉树高度为h，时间 复杂度为0(n)，空间复杂度为0(h)
    
    2)解释算法
    
    3)解释正确性
    
    4)解释时间复杂度、空间复杂度符合要求
    
  - AVL、B树、红黑、splay
  - B-树的insert(key)执行完成之后，关键码key总是位于叶节点中
    B-树的插入操作总是首先尝试将关键码插入到叶节点。但是，如果插入导致叶节点溢出，则会进行节点分裂，并将中间关键码提升到父节点。这个分裂过程可能递归向上。因此，新插入的关键码最终不一定位于叶节点，它有可能在分裂过程中被提升到内部节点。
  - 红黑：
    左根右：表示红黑树是二叉搜索树，即左子树结点值<根节点值<右子树结点值。
    
根叶黑：指根节点是黑色，叶子节点（外部结点、null结点）也都是黑色。

不红红：意思是不存在两个相邻的红结点，即红结点的父结点和孩子结点均是黑色。

黑路同：指从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。

  - 给定二叉树的前序遍历序列和中序遍历序列，可以唯一地确定一颗二叉树 √
  - 高度为h的完全二叉树的个数是2^h

  - 树的边和结点数的关系： e = n-1

  - 结点高度：max{ 所有子结点的高度 }+1
#### 堆
- Floyd建堆算法的过程原理，为何能保证0(n)的时间复杂度。（是数学不想学了）
  相当于合并两个堆，然后上滤下滤调整。
 
  每个内部节点所需的调整时间，正比于其高度而非深度，意思是他是按他子孙到他的距离（高度），而非他祖先到他的距离。（深度）
  
  越高（靠近根）的节点高度越大，但这样的节点数量很少。

  越低的节点高度越小，但这样的节点数量极多。
  
- 举例说明多叉堆比正常二叉堆效率高，分析时间复杂度并说明应该如何分叉
  习题集P202。因为高度低了，所以是logdn
  
- 堆能用数组存储实现吗?
  完全二叉树的每一层都是满的（除了最后一层左对齐），通过层次遍历映射到数组。所以数组可以连续存储，不会浪费空间。这种映射不需要额外存储指针，通过下标计算就能找到父子关系。
  
  根节点：array[1]

对于节点 array[i]：

左孩子：array[2*i]

右孩子：array[2*i + 1]

父节点：array[floor(i/2)]
- 左式堆为什么能够保持0(logn)内执行insert()、delMax()、merge()
  性质：堆序性、节点的左子节点的距离不小于右子节点的距离（左偏性）、结点距离=右子结点距离+1、结点最小的左偏树是完全二叉树

答：在堆合并过程中只需调整少量节点：**节点分布偏向左侧，操作只涉及右侧。**右侧肩部长度控制在Ologn

左偏树保持了堆序性,结构性不作要求。而二叉树的插入、删除、合并是O(logn)

不求甚解好歹是合并了。就是输了的和赢了的左子叶比较比较。。
  
- 前K个最大亮度像素:渲染出了一个图像，要找出其中前K大的所有像素;(像素都是整数，k远小于像素的个数)
  
(1)用堆来实现这个问题，简述基本思想和过程(10分)
为什么用堆？

小顶堆（最小堆）特点：
- 堆顶元素是堆中最小的
- 每次插入/删除后自动调整，保持堆顶最小

用最小堆保存"当前最大的K个元素"：
- 堆里始终只保留K个元素
- 堆顶是这K个里最小的
- 如果新元素比堆顶大，就替换堆顶

算法过程

创建一个大小为K的最小堆（优先队列）

遍历所有像素

如果堆大小<k:直接将像素值加入堆

堆已满：如果当前像素值>堆顶

弹出堆顶

插入当前像素值

遍历结束后，堆中就是前K

s时间复杂度分析：O(NlogK)

(2)用C++代码实现，可以使用STL，采用C++11标准(20分)
在电脑上

删除下滤：将向来最末元素与头元素互换，删末元素，然后顶点慢慢下滤。
插入上滤：末元素，也就是完全二叉树底层。然后上滤。
    
### deque
- 某个队列允许一端入队两端出队，入队过程中可以出队，则当入队顺序为ABCDE时不可能得到EBCAD的出 队顺序
- 双端队列中有头尾指针，经过下面的操作push pop push push pop push push pop pop push pop push，最少需要申请的数组长度为
- 求字符串的无重复子串长度

  胜者树的根节点是冠军；而败者树的根节点记录的是败者（不一定是亚军），败者树需要加一个结点来记录整个比赛的胜利者。

### 栈
- 将中缀表达式（0！+1）*2^（3！+4）-5/6-（7-8+9）转换为逆波兰表达式，写进44455的格子
- 程序实现中缀转后缀重载<运算符用来比较运算符优先级输入:1-2*(3+4)输出:1234+* 还有两年考了
  
 如何将中缀表达式转为后缀表达式
>
> 遍历到数字，直接放在表达式中不进栈
>
> 遍历到+-(随便进栈
> 
> 遍历到），弹出里面的符号，直到找到（匹配他，弹出直接消除。
> 
> 栈顶元素的优先级>=当前扫描到的元素，弹出栈顶元素，放在后缀表达式中。继续比较，弹出，直到<，入栈。扫描完就依次弹出
>
> ）的优先级是最高的，任何高优先级符号都只能乖乖等着。不过只是！和（相比，！碰到+还是！弹出了
>
> 但是碰到（，里面的不弹出

 如何通过后缀表达式，计算最终的结果
> 
> 遍历到数字，进栈
> 
> 遍历到运算符，弹出两个数字，栈顶放右边，第二个放左边，得出数字进栈
>
> ！只和自己算是因为一元运算符

出栈秒杀法：312禁止
> 入栈顺序是ABC，则CAB是不对的
- 括号匹配有个简答题（伪代码、简述原理）
  
#### 向量
- 如何基于向量结构，派生出栈结构
  将向量首端作为栈底，末端作为栈顶，入栈和出栈只能操作向量末端：当入栈（push）时，只在向量末端插入。当出栈（pop）时，只弹出向量末端元素。取顶（top）返回向量末端元素，其他操作默认继承vector类。
  
  这样设计可以保证所有栈操作的时间复杂度都是<kbd>O(1)</kbd>，因为向量的push_back、pop_back、back操作都是常数时间复杂度的。
  （列表一样的）
  
  *多写一点这种基础数据结构派生的题*

- 向量扩容增量操作分摊时间0(1) 倍增是的。总是O（n）。递增各多^n
- 空间申请扩展的时间复杂度。申请一次空间（new）需要消耗O(log n)，删除一次空间同样。是O（1）：系统分配连续内存块
  
需要O(log n)的时间。对于达到M 的空间，n 为每次申请空间，求时间复杂度。 

1. n={1,2,3,4,5… }
   
3. n=(1,2,4,8,16,32…)
   
5. 尝试设计递增算法，使得时间复杂度满足O(log M)

这道题不考我不学了。
   
- 25年动态数组
  记得看new delete细节

  向量扩容缩容和new delete一起练
  
### 复杂度
- 递归算法时间，空间复杂度分别主要决定于哪些因素；
时间复杂度主要决定于：

递归深度（递归调用的层数）

每层递归的工作量

递归分支数（单分支、双分支等）

问题规模n的减少速度

空间复杂度主要决定于：

递归调用栈的最大深度

每层递归的局部变量空间

是否使用辅助数据结构

2)解释算法

3)解释正确性

4)解释时间复杂度、空间复杂度符合要求
- 二叉搜索树(BST)在查找元素最坏情况是0(n)(√)退化为链表

- 2）一个和二叉树相关的算法的思路 3）该算法的时间复杂度。

- 就地算法
就地算法（In-place Algorithm）是指在算法执行过程中，除了输入数据本身占用的空间外，只使用O(1)辅助空间的算法。（e.g.就地堆排序：完全二叉堆就是向量）

- 大O符号是算法复杂度分析的核心工具，用于量化算法时间/空间需求随输入规模增长的变化趋势。它关注最坏情况下的渐近上界，忽略常数因子，突出主导项。
- 在数据集理想随机时，为什么平凡算法和优化算法的效果实质上可能差别不大。举两个例子，并解释。

- 在渐进复杂度中，对数复杂度的常数底会影响复杂度
  在Big-O表示法中，常数因子会被忽略。在渐进分析（Big-O）中，我们关注的是当输入规模n趋于无穷大时，函数的增长趋势。

- 2.021^n=Ω(n^2021)（渐进下界）对，即指数函数 增长比任何多项式 都快得多。

### 图
- 所有的无向图的度都是边数的两倍。（√）

因为每条边一定贡献给两个端点各1度。即便这条边是自环（自己连自己），通常约定自环贡献2度。所以总和总是边数的两倍。
  
- 对比说明邻接矩阵和邻接表的优势和劣势
  邻接矩阵使用矩阵[n][n]描述图的各个顶点的临界关系。对无权图而言，当存在某个顶点指向另一个顶点的边时，就以出点为纵列，入点为横列的单元填入1。在带权网络中，可将矩阵单元用于记录对应边的权重，不存在的边通常取值为0或∞。时间复杂度O（1），得益于向量的循秩访问。空间复杂度最坏情况为O(n^2)，储存稀疏图是空间背大量浪费。

  邻接表是为了改进邻接矩阵空间复杂度，将各个顶点为列表头结点，链接相连的顶点，并记录对应权值。时间复杂度为O（n）,空间复杂度为O(n+e)，与边数成正比。适合稀疏图。
  
- Prim、Kruscal
  prim和Kruscal都是**加权无向联通**图中求解的最小生成树的**贪心**算法，最小生成树是指**包含图中所有顶点且边权和最小的无环联通子图**。两者的核心区别在于贪心的策略不同：
  prim算法采用"加点法"，它从一个初始顶点出发，每一步都选择链接“已选顶点集”与“未选顶点集”的**权值**最小邻边，并将该边连接的未选顶点加入已选集。此过程通常借助优先队列（最小堆）实现，在稠密图中表现较好。
  其本质是使一棵树从单点逐渐“生长”至覆盖全图。
      A    选A为起点，已选集{A}，未选集{B,C,D}
   1/   \3 连AB      已选集{A,B}，未选集{C,D}
   B-----C
   4\  /2
      D
  Kruscal算法采用“加边法”：它首先将图中所有边按权值从小到大排序，然后依次考察每条边，如果加入该边不会与已选边构成环，则将其选中。判断是否成环通常借助并查集这一数据结构高效完成，此方法在边稀疏的图中更具优势。
其本质是将多个连通分量逐步合并为一个。
  从最小权重的边开始，只要不连城环，从小到大依次加边。
  当图中存在多条等权边时，prim算法和kruscal算法得到的最小生成树可能不唯一。
  
- 深度优先搜索能用于判断有向图的回路
DFS可以用于判断有向图是否存在回路。其核心方法是：在递归的深度优先遍历过程中，为每个节点维护“未访问”、“访问中”、“已访问”三种状态。

具体过程如下：

从任意未访问节点开始DFS。

访问一个节点时，将其标记为“访问中”。

遍历该节点的所有出边，对于邻居节点：

若其状态为“未访问”，则递归访问它。

若其状态为“访问中”，则发现了一条指向当前递归栈中祖先的“后向边”，即可判定图中存在回路。

若其状态为“已访问”，则跳过。

该节点的所有邻居处理完毕后，将其状态标记为“已访问”，然后递归返回。

DFS判断回路：用 “三色标记法 + 后向边检查”。

判断环路几乎是这个，因为递归调用栈天然保存了路径，并且通过参数传递父节点，很容易排除掉“回退到父节点”这条边

BFS判断回路：用 “Kahn算法（拓扑排序）+ 入度统计”。
  
- Dijkstra算法可以解决任何图的单源最短路径问题
  不能解决负权边（权值为-1的边），要用Bellman-Ford算法。（就这个问题）
  它假设 “当前从起点出发，找到的距离最短的点，它的最短距离就已经被确定下来了”。

  在所有权重为非负数的图里，这个假设成立。因为你不可能通过绕远路（增加距离）再回来，得到一个更短的距离。

  一旦出现负权边，这个“确定”就失效了。因为可能先绕到一条负权边上“薅羊毛”，把总距离减得更小，从而找到一条更短的路径到达那个“已被确定”的点。

  它能解决“无权图”吗？

  完全可以，而且会退化成 BFS。

  在无权图中，每条边的权值都是 1（或视为相同正数）。 此时，Dijkstra 算法中优先队列的排序逻辑就变成了 “按距离从小到大”，而这个距离其实就是 “从起点出发经过的边数”。 

能解决“树”从起点做一次 DFS 或 BFS，记录到达每个点的距离即可

### 哈希
- 发扑克牌
- 散列函数
- 1)计算序列{2,3,4,6,7,8,9}二分查找的平均查找长度
         
向左是1，向右是2

             6（自带2）
          /    \
        +1     +2 失败的话从这里开始加
        /        \
      3           8
     /  \        /  \
    +1  +2      +1  +2
   /      \    /      \
  2        4  7        9
成功：4.14
失败：4.50
O(1.5·log（以2为底）n)
  
向下取整

- 2)改用散列表法，散列表 A[0,…10],哈希函数为 H(key)=(key^2+2)mod 11，采用链表法处理冲突 ，当查找顺序为{4,7,3,6,8,9,2}时，画出哈希表并计算平均查找长度
  默认采用头插法，也就是新节点插在头部，比如先进4，然后7冲突了，链表是A[7] → [7] → [4]这样
  
A[0] → [8] → [3]

A[5] → [6]

A[6] → [2] → [9] 

A[7] → [7] → [4]

  ASL成功 = (所有关键字查找时的比较次数之和) / 关键字个数
  
查找 key	哈希地址	链表顺序（从头→尾）	比较过程	比较次数

4	   7	   7 → 4	先比7(1次)，再比4(1次)	       2

7    7	   7 → 4	第一个就是7	                 1

3	   0	   8 → 3	先比8(1次)，再比3(1次)      	 2

6	   5	   6	    第一个就是6	                 1

8	   0	   8 → 3	第一个就是8	                 1

9	   6	   2 → 9	先比2(1次)，再比9(1次)	       2

2	   6	   2 → 9	第一个就是2	                 1

还是要先搞出这个链表再查找。。

计算总和：2+1+2+1+1+2+1 = 10 

关键字个数：7 

ASL成功 = 10 / 7 ≈ 1.43

- (2)表长为7的哈希表，哈希公式为hash(x)=(3*x+5)mod7，分别向表中插入16 19 23 42 52 采用线性排解法处理冲突，画出哈希表并算出成功查找长度
  下标 (Address)	       0	 1	  2	    3	   4	 5 	 6
  
存储的关键字 (Key)	      42	52	(空)	(空)	16	23	19

这个的查找长度就是插入时计算的了。

元素	最终位置	插入过程（探测序列）	插入时探查次数（为放入它试了几次）	查找时探查次数（为找到它需要几次）

16	    A[4]	4 ✅	                  1                         	1 (A[4]就是它)

19    	A[6]	6 ✅	                  1	                          1 (A[6]就是它)

23    	A[5]	4冲突 → 5 ✅	          2                          	2 (先查A[4]是16，再查A[5]找到)

42    	A[0]	5冲突 → 6冲突 → 0 ✅	  3	                          3 (查5->6->0)

52	    A[1]	0冲突 → 1 ✅	          2                         	2 (查0->1)

ASL成功 = (1+1+2+3+2)/5 = 1.8

开散列是链表法，闭散列是开放定置也就是平方、线性等
平方是hash(key)+j^2 线性探测法加剧聚集。
再散列可以扩容代码。
### 倒转
- 实现句⼦的逆序输出，如，输⼊：i am a student , 输出：student a am I；
- 逆序输出只识别宇母和空格，逆序输出各个单词输入:love TsingHua University输出:University Tsinghua love l输入:| lo*e Ts/ngHua Un¥vers&ty输出:ty vers Un ngHua Ts e lo l
- 输入一个由数字组成的字符串，将数字与字母对应，求一串数字能够对应的所有非空字母序列，完成转换
- 逆序对
  逆序对是在排序算法中测量不稳定的

### 查找
- 插值查找（就是按比例查找）
- 二路归并
- 二分查找（这是名词解释，25也考了）
- 哈希查找和BST查找都可以算asl的

### 高精度
- 编程实现大数加法。十进制正整数X1 X2 X1 X2 位数不超过1000，最高位不是0，1＜X1＜101000, 1＜X2＜101000，输出两个数的和。
- 高精度阶乘的实现，补全代码。

跳表logn（这我都不知道咋考）

### 字符串
- kmp表
  改进前为一般正常表-1
  
  改进后写笔记了

  bc表之后再说
